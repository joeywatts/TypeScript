=== tests/cases/conformance/classes/members/privateNames/privateNamesUnique-3.ts ===
class Parent {
>Parent : Symbol(Parent, Decl(privateNamesUnique-3.ts, 0, 0))

    #x;
>#x : Symbol(Parent.#x, Decl(privateNamesUnique-3.ts, 0, 14))

    copy(child: Child) {
>copy : Symbol(Parent.copy, Decl(privateNamesUnique-3.ts, 1, 7))
>child : Symbol(child, Decl(privateNamesUnique-3.ts, 2, 9))
>Child : Symbol(Child, Decl(privateNamesUnique-3.ts, 5, 1))

        this.#x = child.#x; // OK (Sub has Super's #x)
>this.#x : Symbol(Parent.#x, Decl(privateNamesUnique-3.ts, 0, 14))
>this : Symbol(Parent, Decl(privateNamesUnique-3.ts, 0, 0))
>child.#x : Symbol(Parent.#x, Decl(privateNamesUnique-3.ts, 0, 14))
>child : Symbol(child, Decl(privateNamesUnique-3.ts, 2, 9))
    }
}

class Child extends Parent {
>Child : Symbol(Child, Decl(privateNamesUnique-3.ts, 5, 1))
>Parent : Symbol(Parent, Decl(privateNamesUnique-3.ts, 0, 0))

    #x; // OK (Child #x lexically shadows Super's #x)
>#x : Symbol(Child.#x, Decl(privateNamesUnique-3.ts, 7, 28))
}

const parent = new Parent();
>parent : Symbol(parent, Decl(privateNamesUnique-3.ts, 11, 5))
>Parent : Symbol(Parent, Decl(privateNamesUnique-3.ts, 0, 0))

const child = new Child();
>child : Symbol(child, Decl(privateNamesUnique-3.ts, 12, 5))
>Child : Symbol(Child, Decl(privateNamesUnique-3.ts, 5, 1))

parent.copy(child); // OK
>parent.copy : Symbol(Parent.copy, Decl(privateNamesUnique-3.ts, 1, 7))
>parent : Symbol(parent, Decl(privateNamesUnique-3.ts, 11, 5))
>copy : Symbol(Parent.copy, Decl(privateNamesUnique-3.ts, 1, 7))
>child : Symbol(child, Decl(privateNamesUnique-3.ts, 12, 5))


export default 3;

